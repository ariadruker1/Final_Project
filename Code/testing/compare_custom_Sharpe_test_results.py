import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(
    os.path.dirname(os.path.abspath(__file__)))))

import pandas as pd
import numpy as np

def quantitative_etf_basket_comparison(
    df,
    custom_tickers,
    sharpe_tickers,
    user_growth,
    user_std,  # [risk_weight, return_weight]
    test_start,
    test_end=None,
    risk_free_rate=0.02,
):
    """
    Compares the quantitative performance of two ETF baskets over a test period.

    This function calculates several key performance metrics for two distinct ETF
    baskets, typically generated by a custom recommendation engine and a
    Sharpe-ratio-based engine. It provides a detailed comparison of their
    risk-adjusted returns, volatility, and downside risk.

    Args:
        df (pd.DataFrame): DataFrame containing historical ETF price data.
        custom_tickers (list): A list of tickers for the custom-recommended ETF basket.
        sharpe_tickers (list): A list of tickers for the Sharpe-recommended ETF basket.
        user_growth (float): The user's desired annual growth rate, used to
                             calculate the Reward to Shortfall metric.
        user_std (float): The user's acceptable annual standard deviation, used to
                          calculate the Reward to Shortfall metric.
        test_start (pd.Timestamp): The start date of the testing period.
        test_end (pd.Timestamp, optional): The end date of the testing period.
                                           Defaults to the current date.
        risk_free_rate (float, optional): The annual risk-free rate, used for
                                          Sharpe and Sortino ratio calculations.
                                          Defaults to 0.02 (2%).

    Returns:
        pd.DataFrame: A DataFrame with the calculated performance metrics for
                      each ETF basket, including Annual Return, Volatility,
                      Sharpe Ratio, Sortino Ratio, and Max Drawdown.
    """
    
    if test_end is None:
        test_end = pd.Timestamp.today()

    df = df.loc[test_start:test_end, :]  # slice the testing period

    # Track unique and overlap
    unique_custom = sorted(set(custom_tickers) - set(sharpe_tickers))
    unique_sharpe = sorted(set(sharpe_tickers) - set(custom_tickers))
    overlap = sorted(set(custom_tickers) & set(sharpe_tickers))
    overlap_count = len(overlap)

    results = []

    for label, tickers in [('Custom', custom_tickers), ('Sharpe', sharpe_tickers)]:
        combined_returns = []

        for ticker in tickers:
            if (ticker, 'Adj Close') not in df.columns:
                print(f"{ticker} not found in test data.")
                continue

            prices = df[(ticker, 'Adj Close')].dropna()
            if len(prices) < 2:
                continue

            returns = prices.pct_change().dropna()
            combined_returns.append(returns)

        if not combined_returns:
            print(f"No valid returns for {label}")
            results.append([
                label, None, None, None, None, None, None,
                unique_custom, unique_sharpe, overlap, overlap_count
            ])
            continue

        test_returns = pd.concat(combined_returns, axis=1).mean(axis=1)

        # Calculate metrics
        ann_return = (1 + test_returns.mean()) ** 252 - 1
        ann_std = test_returns.std() * np.sqrt(252)
        sharpe = (ann_return - risk_free_rate) / ann_std if ann_std else np.nan

        downside = test_returns[test_returns < 0]
        sortino = (ann_return - risk_free_rate) / (downside.std() * np.sqrt(252)) if not downside.empty else np.nan

        cum_returns = (1 + test_returns).cumprod()
        peak = cum_returns.cummax()
        drawdown = (cum_returns - peak) / peak
        max_dd = drawdown.min()

        if user_growth is not None and user_std is not None:
            threshold = (user_growth - user_std) / 100 / 252
            shortfalls = np.where(test_returns < threshold, threshold - test_returns, 0)
            mean_shortfall = np.mean(shortfalls)
            reward_to_shortfall = ann_return * 100 - mean_shortfall * 100
        else:
            mean_shortfall = np.nan
            reward_to_shortfall = np.nan

        results.append([
            label,
            round(ann_return * 100, 2),
            round(ann_std * 100, 2),
            round(sharpe, 2),
            round(sortino, 2) if not np.isnan(sortino) else None,
            round(max_dd * 100, 2),
            round(reward_to_shortfall, 2),
            unique_custom, unique_sharpe, overlap, overlap_count
        ])

    return pd.DataFrame(results, columns=[
        'method', 'Annual Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino',
        'Max Drawdown (%)', 'Reward to Shortfall',
        'Unique Custom ETFs', 'Unique Sharpe ETFs', 'Overlapping ETFs', 'Overlap Count'
    ]).set_index('method')
